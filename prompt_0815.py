# -*- coding: utf-8 -*-
"""prompt_0815.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WZxOXf_k4WJRDoBJji2S9D58hEVl2v19

Prompt 模板庫（Template Library）
"""

# 全域模板庫
'''
設定動態指令
'''

PROMPT_TEMPLATES = {
    # 行為 1：問答（簡短自然語言）
    "qa": """
任務：QA
- **回答問題**字數總計不得超過 200 字
- 根據學生參與度調整語氣與解釋深度
- 輸出需依照以下結構：
  - 「### 回答問題」：針對學生問題進行解答
  - 「### 引導提問」：{extended_question}

### 回答風格設定
回應風格: {style}
學生的參與度: {engagement}
學習階段: {stage}
問題: {question}
教材: {materials}
""",

    # 行為 2：教學（教材結構化）
"tutoring": """
任務：教學
輸出需依照以下結構：
  - 「### 教學重點」：解釋核心概念，理性陳述單元內容與重點。
  - 「### 範例」：提供簡單範例或 python 程式碼示例，並使用指定教學策略。
  - 「### 總結」：總結重點回顧，簡潔明瞭。
  - 「### 引導提問」：{extended_question}

### 回答風格設定
回應風格: {style}
學生的參與度: {engagement}
學習階段: {stage}
教材: {materials}
"""

}

### 系統指令 System Prompt 包含變數identity

SYSTEM_PROMPT = """
你是一位智慧助教，專精於資料結構教學。
教學對象：{identity},{strategy}
你需要根據學生的「學習參與度」調整語氣、解釋深度與互動方式。

### 規則
1. 使用自然語言分段回答，可使用 Markdown 或表格。
2. 語氣需「溫暖、易於理解」。
3. 直接回應問題，不要打招呼。
4. 全文需使用繁體中文。
5. 請依照教材內容進行回應
6. 範例使用語言標籤 (例如 ```python)
7. 以學生需求為主，學習參與度調整為輔
"""
def map_identity_to_strategy(identity):
  mapping = {
    '資訊管理系大學生':'''請以專業術語講解，提供程式碼範例。''',
    '非資訊領域大學生':'''請循序漸進，不要一次丟太多資訊。避免使用專業術語。'''}
  return mapping.get(identity, "請根據學生程度調整教學方式。")
def set_system_prompt(identity='資訊管理系大學生'):
  '''
  input: identity
  return: new Systemprompt
  '''
  global SYSTEM_PROMPT
  strategy = map_identity_to_strategy(identity)

  SYSTEM_PROMPT = SYSTEM_PROMPT.format(identity=identity, strategy=strategy)
  return SYSTEM_PROMPT.format(identity=identity, strategy=strategy)

print(set_system_prompt())

'''
# 映射方法：情緒 → 語氣 + 教學策略
def map_emotion_to_profile(emotion):
  mapping = {
      "挫折": {"tone": "溫暖且安撫", "style": "循序漸進、拆解問題"},
      "困惑": {"tone": "溫和且耐心", "style": "舉例對照、比喻解釋"},
      "無聊": {"tone": "活潑且有趣", "style": "加入情境化案例、互動提問"},
      "投入": {"tone": "積極且肯定", "style": "深入探討、引導延伸思考"},
      "驚訝": {"tone": "熱情且鼓勵", "style": "延伸趣味點、引入新視角"},
      "喜悅": {"tone": "輕鬆且正向", "style": "融入挑戰題、鼓勵自我探索"},
  }
  return mapping.get(emotion, {"tone": "中性", "style": "一般解釋"})

# 映射方法：參與度 → 語氣 + 教學策略
'''
def map_engagement_to_profile(engagement: str) -> dict:
    """
    根據學生參與度返回教學風格與引導提問設定。
    engagement: 'high' 或 'low'
    回傳 dict 內含:
      - style: 教學回覆風格描述
      - extended_question: 引導提問策略
    """
    mapping = {
      "high": {
        "style": '''- 語氣：積極且肯定
- 教學風格：引導延伸思考，促使挑戰性學習
- 回覆時：提供更深入的概念解釋''',
        "extended_question": '提出與學生問題相關的延伸思考問題或學習的下一步建議'
      },
      "low": {
        "style": '''- 語氣：溫和且耐心
- 教學風格：降低學習困難度，舉例對照、比喻解釋
- 回覆時：用簡單清楚的方式解釋概念，加入生活化例子，結尾加入正向鼓勵。''',
        "extended_question": '提出學生可能產生問題的原因，避免挑戰性問題或額外延伸'
      }
    }

    # 若傳入的 engagement 不在 mapping，提供預設安全回覆
    return mapping.get(engagement, {
        "style": "提供直接的解釋，避免額外挑戰或比喻",
        "extended_question": "提供學習的下一步建議"
    })




# 主方法：回答學生提問。使用學習參與度
def generate_prompt(engagement, question, materials, stage='初學'):
  materials_text = "\n".join(f"{i+1}. {m}" for i, m in enumerate(materials))
  template = PROMPT_TEMPLATES["qa"]
  mapping=map_engagement_to_profile(engagement),
  prompt_text = template.format(
      style=mapping["style"],
      extended_question=mapping["extended_question"],
      engagement=engagement,
      question=question,
      stage=stage,
      materials=materials_text
  )
  return prompt_text


# 根據教材進行教學
def generate_materials(engagement ,materials ,stage="初學"):
  materials_text = "\n".join(f"{i+1}. {m}" for i, m in enumerate(materials))
  template = PROMPT_TEMPLATES["tutoring"]
  mapping=map_engagement_to_profile(engagement),
  prompt_text = template.format(
      style=mapping["style"],
      engagement=engagement,
      materials=materials_text,
      stage=stage,
      extended_question=mapping["extended_question"]
  )
  return prompt_text

"""格式整理工具"""

def clean_text_tutoring(raw_text: str) -> dict:
  import re
  """
  將 Markdown 格式 (含 ### 教學重點、範例、總結、引導提問) 轉成 dict
  """
  sections = {
      "teaching": "",
      "example": "",
      "summary": "",
      "extended_question": ""
  }

  # 確保最後有換行，避免最後一段抓不到
  raw_text = raw_text.strip() + "\n"

  # 改良正則，多行匹配
  pattern = r"###\s*(教學重點|範例|總結|引導提問)\s*([\s\S]*?)(?=\n###|\Z)"
  matches = re.findall(pattern, raw_text)

  for title, content in matches:
    content = content.strip()
    if title == "教學重點":
        sections["teaching"] = content
    elif title == "範例":
        sections["example"] = content
    elif title == "總結":
        sections["summary"] = content
    elif title == "引導提問":
        sections["extended_question"] = content

  if not sections["summary"]:
    sections["summary"] = "（模型未輸出）"
  if not sections["extended_question"]:
    sections["extended_question"] = "模型未輸出問題"


  return sections



def clean_text_qa(raw_text: str) -> dict:
  import re
  """
  將 QA 模式回應解析成 dict
  {
      "answer": "回答內容",
      "extended_question": "引導提問"
  }
  """
  sections = {"answer": "", "extended_question": ""}

  # 確保最後有換行，避免最後一段抓不到
  raw_text = raw_text.strip() + "\n"

  # 匹配兩個區塊
  pattern = r"###\s*(回答問題|引導提問)\s*([\s\S]*?)(?=\n###|\Z)"
  matches = re.findall(pattern, raw_text)

  for title, content in matches:
      content = content.strip()
      if title == "回答問題":
          sections["answer"] = content
      elif title == "引導提問":
          sections["extended_question"] = content

  if not sections["answer"]:
      sections["answer"] = "（模型未輸出回答）"
  if not sections["extended_question"]:
      sections["extended_question"] = "（模型未輸出回答）"

  return sections

"""測資："""

test_clean_text_tutoring = '''
### 教學重點
鏈結串列是一種線性資料結構。

### 範例
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
````

### 總結

鏈結串列允許動態調整大小，適合頻繁插入刪除的場景。

### 引導提問

為什麼需要鏈結串列？
'''
test_clean_text_cleaned = clean_text_tutoring(test_clean_text_tutoring)
print("教學重點:\n", test_clean_text_cleaned["teaching"])
print("範例:\n", test_clean_text_cleaned["example"])
print("總結:\n", test_clean_text_cleaned["summary"])
print("引導提問:\n", test_clean_text_cleaned["extended_question"])

test_clean_text_qa = '''
### 回答問題
鏈結串列是一種線性資料結構。

### 引導提問
為什麼需要鏈結串列？
'''
test_clean_text_qa_cleaned = clean_text_qa(test_clean_text_qa)
print("【QA測試】")
print("回答問題:\n", test_clean_text_qa_cleaned["answer"])
print("引導提問:\n", test_clean_text_qa_cleaned["extended_question"])

test_high = {
  "參與度": "high",
  "提問": "我大概懂 linked list 是什麼，但不知道它比 array 的優勢在哪裡？",
  "教材": [
    "Array 是連續的記憶體空間，存取速度快，但插入與刪除元素需要搬移其他元素。",
    "Linked List 使用節點（Node）來串接，每個節點包含資料與指向下一個節點的指標，適合頻繁插入與刪除的情境。",
    "Linked List 的缺點是存取速度較慢，因為必須從頭逐一走訪節點。"
  ],
}

test_low = {
  "參與度": "low",
  "提問": "我看不懂 linked list 到底是什麼？",
  "教材": [
    "Linked List 是一種資料結構，由一系列的節點組成。",
    "每個節點包含資料與一個指向下一個節點的參考。",
    "與 Array 不同，Linked List 的元素並非連續存放在記憶體中。"
  ]
}
