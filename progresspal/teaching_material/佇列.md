# 4 資料結構章節: 佇列

## 4-1 佇列簡介

### 4-1-1 什麼是佇列

佇列（Queue）是一種線性資料結構，遵循先進先出（FIFO, First-In-First-Out）原則。最先加入的元素最先被移除，類似超市排隊。可想像成超市排隊，最先排隊的人是最先結帳離開的人。

### 4-1-2 佇列的基本操作

- **Enqueue**：將元素加入佇列尾端。
- **Dequeue**：從佇列頭端移除並返回元素。
- **Peek**：取得佇列頭端元素但不移除。
- **isEmpty**：檢查佇列是否為空。
- **Size**：取得佇列中元素的數量。


### 4-1-3 佇列的應用

佇列在生活與電腦科學中應用廣泛，以下舉例：
1. **排隊系統**：  
   例如超市收銀台、醫院掛號，先來的人先服務，後來的人必須等待。
2. **作業系統排程**：  
   CPU 工作排程常使用佇列來管理程序（Process），如先來先服務（FCFS, First-Come-First-Serve）。
3. **印表機工作管理**：  
   多個檔案同時送出列印請求時，會進入佇列，依照順序依次列印。
4. **網路資料封包處理**：  
   封包進入路由器或交換器時，會暫存在佇列中，再依序傳送。
5. **模擬系統（Simulation）**：  
   用於模擬顧客到達、機器運作等需要「等待排隊」的場景。

## 4-2 佇列的實作方式

### 4-2-1使用 Python 列表實作佇列

Python 的列表（list）可簡單當作佇列使用，使用 `append()` 進行 enqueue，使用 `pop(0)` 進行 dequeue。
缺點是 `pop(0)` 會導致所有元素前移，時間複雜度為 O(n)，適合小規模資料。

範例：

```python
queue = []
queue.append('A')  # Enqueue
queue.append('B')
queue.append('C')
print("Queue:", queue)  # ['A', 'B', 'C']
print("Dequeue:", queue.pop(0))  # 'A'
print("Queue after Dequeue:", queue)  # ['B', 'C']
```


### 4-2-2 使用 Python 類別封裝佇列

利用類別封裝佇列操作，使得佇列更加結構化方便使用。

範例：

```python
class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, element):
        self.queue.append(element)

    def dequeue(self):
        if self.isEmpty():
            return "Queue is empty"
        return self.queue.pop(0)

    def peek(self):
        if self.isEmpty():
            return "Queue is empty"
        return self.queue[^0]

    def isEmpty(self):
        return len(self.queue) == 0

    def size(self):
        return len(self.queue)
```


### 4-2-3 使用鏈結串列（Linked List）實作佇列

鏈結串列不動態空間分配，節點不需連續儲存。加入或移除節點時不需資料搬移，效率較好。
節點類別定義：每個節點包含資料與指向下一節點的指標。

佇列類別操作:
- `front`：指向佇列頭節點。
- `rear`：指向佇列尾節點。
- Enqueue 時新增節點到尾端，Dequeue 時移除頭節點。

範例：

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self):
        self.front = None
        self.rear = None
        self.length = 0

    def enqueue(self, element):
        new_node = Node(element)
        if self.rear is None:
            self.front = self.rear = new_node
        else:
            self.rear.next = new_node
            self.rear = new_node
        self.length += 1

    def dequeue(self):
        if self.isEmpty():
            return "Queue is empty"
        temp = self.front
        self.front = temp.next
        self.length -= 1
        if self.front is None:
            self.rear = None
        return temp.data

    def peek(self):
        if self.isEmpty():
            return "Queue is empty"
        return self.front.data

    def isEmpty(self):
        return self.length == 0

    def size(self):
        return self.length
```

- 優點：可以動態增減元素、移除頭元素時無需搬移資料。
- 缺點：每個元素需額外存儲指標，程式碼相對較複雜。


## 4-3 佇列進階概念與應用

### 4-3-1 其他佇列實作方法

- `collections.deque`：雙端佇列，效率高且可雙端進行元素的新增與刪除，常用於需要頻繁頭尾操作的情境。
- `queue.Queue`：標準庫內建的執行緒安全隊列，內建鎖機制避免資料競爭，讓不同執行緒能安全地存取佇列，適合多工任務排程與即時系統。。
- 優先佇列（Priority Queue）：依優先順序而非FIFO進行元素排序，應用於排程演算法、路徑搜尋（如 Dijkstra 演算法）等。


### 4-3-2 常見佇列應用範例

- 作業系統排程：利用佇列管理多個行程，確保每個行程依序獲得 CPU 執行時間。
- 廣度優先搜尋（圖形演算法）：需要佇列來記錄待訪節點，保證搜尋順序由近至遠。
- 網路訊息佇列與分布式系統訊息排程：訊息佇列可暫存資料封包或任務，避免因網路延遲或處理速度不同而造成資料遺失。

***