# 2 鏈結串列

## 2-1 什麼是鏈結串列

### 2-1-1 定義與基本概念
**鏈結串列（Linked List）**是一種**線性資料結構**，其元素並非儲存於連續的記憶體空間中，而是以**節點（Node）**的形式存在。每個節點都是一個獨立的物件。

-   在鏈結串列中，各個節點透過 **「引用」（Reference）**或 **「指標」（Pointer）**相連接，形成一個有順序的排列。
-   **引用/指標**記錄了下一個節點的記憶體位址，透過它，可以從當前節點訪問到鏈結串列中的下一個節點。

### 2-1-2 鏈結串列的組成
鏈結串列的基本組成單位是**節點（Node）**。一個典型的節點通常包含以下兩部分資料:

-   **節點值（Data/Val）**：用於儲存節點的實際資訊或資料。
-   **引用/指標（Next pointer/Reference）**：指向鏈結串列中下一個節點的記憶體位址。在C、C++、Go、Rust等支援指標的程式語言中，此通常被稱為「指標」。

此外，鏈結串列還有以下重要概念：

-   **頭節點（Head）**：是鏈結串列的首個節點。在實際程式設計中，我們通常將頭節點作為整個鏈結串列的代稱。如果鏈結串列為空，頭指標通常會指向 `null`、`nullptr` 或 `None`。
-   **尾節點（Tail）**：是鏈結串列的最後一個節點。尾節點的「引用」部分會指向**空（null/nullptr/None）**，表示鏈結串列的結束。

### 2-1-3 Python 節點類別範例

```python
class Node:
    def __init__(self, data):
        self.data = data   # 節點值
        self.next = None   # 指向下一個節點
```

### 2-1-4 鏈結串列的記憶體儲存方式
鏈結串列的設計使得其**各個節點可以分散儲存在記憶體的各個位置**，它們的記憶體位址**無須連續**。這與陣列要求連續記憶體空間的儲存方式形成對比。

然而，由於每個節點除了儲存其值之外，還需要額外儲存一個引用（或指標）來指向下一個節點，因此在儲存相同資料量的情況下，**鏈結串列會比陣列佔用更多的記憶體空間**。

## 2-2 鏈結串列的常用操作

### 2-2-1 初始化鏈結串列
建立一個鏈結串列通常分為兩個主要步驟:

1.  **初始化各個節點物件**：為每個要儲存的資料元素建立一個新的節點物件。
2.  **構建節點之間的引用關係**：將每個節點的 `next` 引用（或指標）設置為指向其後繼節點。這個過程會一直持續到鏈結串列的尾節點，其 `next` 引用會指向空（`None`/`null`）。

初始化完成後，即可從頭節點出發，透過依序追蹤每個節點的 `next` 引用來訪問鏈結串列中的所有節點。
3.  **程式碼範例**：
```python
# 建立三個節點
n1 = Node(10)
n2 = Node(20)
n3 = Node(30)

# 連結節點
n1.next = n2
n2.next = n3

# 頭節點 (Head)
head = n1

```
### 2-2-2 插入節點
在鏈結串列中插入新節點是一個**非常容易且高效**的操作。

-   **高效性**：插入一個節點**只需改變兩個節點的引用（指標）即可**。
-   **時間複雜度**：在已知插入位置的情況下，插入操作的**時間複雜度為 \(O(1)\)**。
-   **與陣列的對比**：相較之下，在陣列中插入元素的時間複雜度為 \(O(n)\)，因為需要移動插入點之後的所有元素，在大資料量下效率較低。
-   插入操作可以應用於鏈結串列的開頭、結尾或特定位置之後。
- **程式碼範例**：
```python
def insert_after(prev_node, new_data):
    if not prev_node:
        return
    new_node = Node(new_data)
    new_node.next = prev_node.next
    prev_node.next = new_node

# 範例：在 n1(10) 後插入 15
insert_after(n1, 15)

```
### 2-2-3 刪除節點
在鏈結串列中刪除節點同樣**非常方便且高效**。

-   **高效性**：刪除一個節點**只需改變一個節點的引用（指標）即可**。
-   **時間複雜度**：刪除操作的**時間複雜度為 \(O(1)\)**。
-   **節點狀態**：儘管在刪除操作完成後，被刪除的節點 `P` 可能仍然指向 `n1`，但透過走訪鏈結串列已無法再訪問到 `P`，這意味著 `P` 已經不再屬於該鏈結串列了。
-   刪除操作可以應用於鏈結串列的開頭、結尾或特定節點。
- **程式碼範例**：
```python
def delete_node(head, key):
    # 刪除第一個節點
    if head and head.data == key:
        return head.next

    prev, curr = None, head
    while curr and curr.data != key:
        prev, curr = curr, curr.next

    if curr:
        prev.next = curr.next
    return head

# 範例：刪除數值為 20 的節點
head = delete_node(head, 20)

```
### 2-2-4 訪問節點
**在鏈結串列中訪問特定位置的節點效率較低**。

-   **存取方式**：與陣列可以在 \(O(1)\) 時間內透過索引隨機訪問任意元素不同，鏈結串列無法直接跳轉到指定位置。
-   **操作過程**：程式必須從頭節點出發，**逐個向後走訪**每個節點，直到找到目標節點。
-   **時間複雜度**：訪問鏈結串列的第 \(i\) 個節點需要迴圈 \(i-1\) 輪，因此其**時間複雜度為 \(O(n)\)**。
-   **程式碼範例**：
```python
def get_node(head, index):
    curr = head
    count = 0
    while curr:
        if count == index:
            return curr.data
        curr = curr.next
        count += 1
    return None

# 範例：取得第 2 個節點 (0-based)
print(get_node(head, 2))  
```
### 2-2-5 查詢節點
查詢鏈結串列中具有特定值的節點，並輸出其索引，這個過程也屬於**線性查詢**。

-   **操作過程**：程式需要從頭節點開始，**依序遍歷**每個節點，檢查其節點值是否與目標值 `target` 相符。
-   **時間複雜度**：與訪問節點類似，查詢操作的**時間複雜度為 \(O(n)\)**。
-   **程式碼範例**：
```python
def search(head, target):
    curr = head
    index = 0
    while curr:
        if curr.data == target:
            return index
        curr = curr.next
        index += 1
    return -1

# 範例：查詢數值 30
print(search(head, 30))  # 輸出索引位置
```

## 2-3 鏈結串列的類型
### 2-3-1 單向鏈結串列 (Singly Linked List)
這是最基本和常見的鏈結串列形式。

-   **節點結構**：每個節點包含其**節點值**和**一個指向下一節點的引用**。
-   **追蹤方向**：只能從頭節點沿著 `next` 引用**單方向地**往後追蹤到尾節點。
-   **鏈結串列的結束**：鏈結串列的**尾節點**，其 `next` 引用會指向**空（`None`/`Null`）**，表示鏈結串列的終點。

### 2-3-2 環狀鏈結串列 (Circular Linked List)
環狀鏈結串列是單向鏈結串列的一種特殊變體。

-   **結構特點**：它的獨特之處在於**尾節點的引用會指向頭節點**，從而形成一個首尾相接的環形結構。
-   **追蹤靈活性**：由於形成環形，在環狀鏈結串列中，**任意節點都可以被視作頭節點**。這意味著可以從任何一個節點開始追蹤並訪問所有其他節點，並且可以從「尾部」追蹤回「頭部」，重新開始搜尋或遍歷。
-   **單元素情況**：當環狀鏈結串列中只有一個元素時，該節點的 `next` 引用會指向自身，形成一個自環。
-   **程式碼範例**：
```python
# 建立一個環狀鏈結串列
n1 = Node(1)
n2 = Node(2)
n3 = Node(3)
n1.next = n2
n2.next = n3
n3.next = n1  # 形成環

# 遍歷前 5 個節點（避免無限循環）
curr = n1
for _ in range(5):
    print(curr.data, end=" -> ")
    curr = curr.next
```

### 2-3-3 雙向鏈結串列 (Doubly Linked List)
雙向鏈結串列在功能上比單向鏈結串列更為靈活。

-   **節點結構**：除了包含**節點值**和**指向後繼節點（下一個節點）的引用（通常稱為 `next` 或 `RLINK`）**之外，每個節點還額外包含一個**指向前驅節點（上一個節點）的引用（通常稱為 `prev` 或 `LLINK`）**。
-   **追蹤靈活性**：由於記錄了兩個方向的引用，雙向鏈結串列可以**朝兩個方向（向前和向後）走訪**，大大增加了操作的彈性。
-   **成本**：這種靈活性帶來了額外的成本。每個節點需要佔用更多的記憶體空間來儲存 `prev` 引用，同時在插入和刪除操作時，需要維護兩個引用，導致維護複雜度稍高。
-   **特性**：若 `ptr` 指向雙向鏈結串列中的任何節點，則 `ptr` 應該等於 `ptr` 的左鏈結再取右鏈結，也等於 `ptr` 的右鏈結再取左鏈結 (`ptr == ptr->llink->rlink == ptr->rlink->llink`)。
-   **單元素情況**：當雙向鏈結串列只有一個元素時，該節點的 `next` 和 `prev` 引用會同時指向自身，形成一個自環。
-   **空串列**：如果鏈結串列是空的，則通常只會有一個串列首（head node），其資料欄位不存放資料。
-   **程式碼範例**：
```python
class DNode:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# 建立雙向鏈結串列
n1 = DNode(10)
n2 = DNode(20)
n3 = DNode(30)

n1.next = n2
n2.prev = n1
n2.next = n3
n3.prev = n2

```

## 2-4 鏈結串列與陣列的比較

### 2-4-1 儲存方式與容量擴展
-   **陣列**：
    -   **儲存方式**：元素儲存在**連續的記憶體空間**中。
    -   **容量擴展**：長度通常**不可變**。若需要擴展容量，通常需要分配一個更大的新記憶體區塊，然後將所有現有元素複製到新區塊中。
-   **鏈結串列**：
    -   **儲存方式**：節點可以**分散儲存在記憶體各處**，它們的記憶體位址無須連續。
    -   **容量擴展**：具有**動態大小**的特性，可以根據需求在執行時彈性地分配或釋放記憶體。這使得鏈結串列可以**靈活擴展**，避免了陣列在大小上的限制。

### 2-4-2 記憶體效率
-   **陣列**：
    -   每個元素僅佔用其資料所需的記憶體空間，元素佔用記憶體較少。
    -   然而，若預先分配過大的空間，可能導致**記憶體浪費**。
-   **鏈結串列**：
    -   每個節點除了儲存資料，還需要額外儲存一個或多個引用（指標），因此在相同資料量下，**鏈結串列比陣列佔用更多的記憶體空間**。
    -   儘管有額外開銷，但其動態調整大小的特性有助於避免不必要的記憶體浪費。
    -   由於節點在記憶體中可能不連續，這會導致**快取（Cache）不友好**，可能降低快取命中率，進而影響效能。

### 2-4-3 操作效率對比
| 操作               | 鏈結串列 (Linked List)                               | 陣列 (Array)                                 |
| :----------------- | :--------------------------------------------------- | :------------------------------------------- |
| **儲存方式**       | 分散記憶體空間                                       | 連續記憶體空間                               |   
| **容量擴展**       | 可靈活擴展                                           | 長度不可變（或需重新分配）                     |   
| **記憶體效率**     | 元素佔用記憶體多（因指標開銷）                       | 元素佔用記憶體少、但可能浪費空間             | 
| **訪問元素 (隨機存取)** | **O(n)** (需從頭遍歷)                              | **O(1)** (直接索引)                          | 
| **新增元素**       | **O(1)** (只需修改引用)                              | **O(n)** (需搬移元素)                        | 
| **刪除元素**       | **O(1)** (只需修改引用)                              | **O(n)** (需搬移元素)                        | 
| **查詢元素**       | **O(n)** (需從頭遍歷)                                | **O(n)** (線性掃描)                          |       
| **在開頭插入/刪除** | **O(1)**                                             | **O(n)**                                     |      
| **在結尾插入/刪除** | **O(n)** (若只維護頭指標)                             | **O(1)**                                     |      
| **在任意位置插入/刪除** | **O(n)** (找到位置需O(n)，實際修改引用O(1))             | **O(n)**                                     |      

## 2-5 鏈結串列的優缺點

### 2-5-1 優點
-   **動態大小**：鏈結串列不需要在建立時預先指定固定大小，可以在程式執行時根據需要彈性地增減元素，從而動態地分配或釋放記憶體，有效避免了記憶體浪費和陣列在大小上的限制。
-   **高效的插入和刪除操作**：在已知插入或刪除位置的情況下，鏈結串列只需修改節點之間的引用（指標），而無需移動大量元素。這使得其在某些情況下（尤其是在列表的開頭或中間）的插入和刪除操作效率極高，**時間複雜度為 \(O(1)\)**。
-   **實現複雜資料結構的基礎**：鏈結串列是許多其他高階資料結構的基礎，例如堆疊（Stack）、佇列（Queue）、雜湊表（Hash Table）和圖（Graph）等。

### 2-5-2 缺點
-   **僅能依序存取（無隨機存取）**：鏈結串列最大的缺點是無法像陣列一樣透過索引值直接隨機存取任意元素。若要查找或訪問特定位置的元素，必須從頭節點開始，**逐個遍歷**，直到找到目標，導致查詢效率較低。其訪問和查詢的時間複雜度為 **\(O(n)\)**。
-   **額外的記憶體開銷**：每個節點除了儲存實際資料外，還需要額外儲存一個或多個引用（指標），這會增加鏈結串列的整體記憶體消耗。
-   **快取不友好（Cache Unfriendly）**：由於鏈結串列的節點在記憶體中是分散儲存的，不保證記憶體連續性，這會降低 CPU 快取（Cache）的命中率，可能對程式的執行效能產生負面影響。

## 2-6 鏈結串列的典型應用

### 2-6-1 單向鏈結串列應用
單向鏈結串列是實現許多基礎資料結構的基石。

-   **堆疊（Stack）與佇列（Queue）**：
    -   當插入和刪除操作都發生在鏈結串列的同一端時，它表現出**先進後出（LIFO）**的特性，可以實現**堆疊**。
    -   當插入操作在鏈結串列的一端進行，而刪除操作在鏈結串列的另一端進行時，它表現出**先進先出（FIFO）**的特性，可以實現**佇列**。
-   **雜湊表（Hash Table）**：在解決雜湊衝突時，鏈式位址法（Chaining）是一種主流方案。在此方案中，所有發生衝突的元素會被組織到一個鏈結串列中。
-   **圖（Graph）**：鄰接表（Adjacency List）是表示圖的一種常用方式。其中，圖的每個頂點都與一個鏈結串列相關聯，鏈結串列中的每個元素代表與該頂點相連的其他頂點。

### 2-6-2 雙向鏈結串列應用
雙向鏈結串列常用於需要**快速查詢前一個和後一個元素**的場景，或需要雙向遍歷的功能。

-   **高階資料結構**：在某些複雜的樹結構（如紅黑樹、B樹）中，我們可能需要訪問節點的父節點。這可以透過在節點中儲存一個指向父節點的引用來實現，其概念類似於雙向鏈結串列的 `prev` 引用。
-   **瀏覽器歷史**：在網頁瀏覽器中，當使用者點擊「前進」或「後退」按鈕時，瀏覽器需要快速知道使用者訪問過的前一個和後一個網頁。雙向鏈結串列的雙向追蹤特性使得這種操作變得簡單高效。
-   **LRU 演算法（Least Recently Used）**：在快取淘汰演算法中，LRU 演算法需要快速找到最近最少使用的資料，並支援快速地新增和刪除節點。雙向鏈結串列因其高效的插入和刪除特性（特別是在知道節點位置的情況下），非常適合這種應用。

### 2-6-3 環狀鏈結串列應用
環狀鏈結串列因其循環特性，常用於需要**週期性操作**或循環處理的場景。

-   **時間片輪轉排程演算法**：在作業系統中，時間片輪轉排程演算法是一種常見的 CPU 排程策略，它需要對一組程序進行循環處理。每個程序被賦予一個時間片，當時間片用完時，CPU 會切換到環中的下一個程序。這種循環操作可以透過環狀鏈結串列來高效實現。
-   **資料緩衝區**：在某些資料緩衝區的實現中，例如音訊或影片播放器，資料流可能會被分成多個緩衝塊並放入一個環狀鏈結串列。這有助於實現無縫播放，確保資料的循環利用和連續性。