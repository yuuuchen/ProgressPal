chapter,difficulty,question,option_A,option_B,option_C,option_D,answer,explanation
"2","easy","根據 2-1-1 定義，鏈結串列（Linked List）的元素在記憶體中是如何儲存的？","A. 儲存於連續的記憶體空間，類似陣列。","B. 元素以節點形式存在，分散儲存於記憶體各處，透過引用相連。","C. 所有元素必須儲存在同一個記憶體分頁（Page）中。","D. 元素儲存在堆疊（Stack）區段，且位址連續。","B","根據 2-1-1，鏈結串列元素「並非儲存於連續的記憶體空間中，而是以節點（Node）的形式存在」，且 2-1-4 指出「各個節點可以分散儲存在記憶體的各個位置」。選項 A、C、D 皆描述錯誤。"
"2","easy","根據 2-1-2，一個典型的鏈結串列節點（Node）通常包含哪兩部分資料？","A. 索引值（Index）與 資料（Data）。","B. 節點值（Data）與 指向下一個節點的引用（Next pointer）。","C. 前一個節點的位址（Prev）與 後一個節點的位址（Next）。","D. 節點的記憶體大小（Size）與 節點值（Data）。","B","根據 2-1-2，節點包含「節點值（Data/Val）」與「引用/指標（Next pointer/Reference）」。選項 A 的索引是陣列的概念；選項 C 是雙向鏈結串列才有的特徵，非典型基本節點；選項 D 未提及。"
"2","easy","依據 2-3-1，在單向鏈結串列中，尾節點（Tail）的 `next` 引用通常指向什麼？","A. 頭節點（Head）。","B. 鏈結串列的中間節點。","C. 空（None/Null）。","D. 自身的記憶體位址。","C","根據 2-3-1，單向鏈結串列的尾節點，其 `next` 引用會指向「空（None/Null）」，表示鏈結串列的終點。選項 A 是環狀鏈結串列的特徵。"
"2","easy","根據 2-5-1，鏈結串列相較於陣列的一個主要優點是什麼？","A. 支援隨機存取，可快速讀取任意元素。","B. 記憶體使用效率極高，完全沒有額外開銷。","C. 具有動態大小，可依需求彈性增減元素，避免大小限制。","D. 對 CPU 快取（Cache）非常友好。","C","根據 2-5-1，鏈結串列優點為「動態大小」，不需預先指定固定大小。選項 A、D 是陣列的優點（或鏈結串列的缺點）；選項 B 錯誤，鏈結串列有指標的額外記憶體開銷。"
"2","easy","依據 2-2-4，鏈結串列訪問特定位置（如第 i 個）節點的時間複雜度為何？","A. $O(1)$","B. $O(\log n)$","C. $O(n)$","D. $O(n^2)$","C","根據 2-2-4，鏈結串列無法直接跳轉，必須從頭「逐個向後走訪」，因此時間複雜度為 $O(n)$。"
"2","easy","根據 2-3-3，雙向鏈結串列（Doubly Linked List）的每個節點除了 `next` 引用外，還多了一個什麼引用？","A. `head` (指向頭節點)","B. `tail` (指向尾節點)","C. `prev` (指向前驅節點)","D. `root` (指向根節點)","C","根據 2-3-3，雙向鏈結串列每個節點額外包含一個「指向前驅節點（上一個節點）的引用（通常稱為 prev 或 LLINK）」。"
"2","easy","根據 2-2-2，在已知插入位置的情況下，鏈結串列插入新節點的時間複雜度為何？","A. $O(1)$","B. $O(n)$","C. $O(\log n)$","D. $O(n \log n)$","A","根據 2-2-2，在已知插入位置的情況下，插入操作只需改變兩個節點的引用，時間複雜度為 $O(1)$。"
"2","easy","依據 2-6-3，下列哪一個應用場景最適合使用「環狀鏈結串列」？","A. 網頁瀏覽器的上一頁/下一頁功能。","B. 作業系統的「時間片輪轉排程演算法」。","C. 實作先進後出的堆疊（Stack）。","D. 儲存瀏覽紀錄。","B"," 根據 2-6-3，環狀鏈結串列因其循環特性，常用於「時間片輪轉排程演算法」。選項 A、D 適合雙向鏈結串列；選項 C 適合單向鏈結串列。"
"2","easy","根據 2-3-2，環狀鏈結串列與單向鏈結串列的主要結構差異為何？","A. 環狀鏈結串列可以雙向遍歷。","B. 環狀鏈結串列的尾節點指向頭節點，形成環形。","C. 環狀鏈結串列沒有頭節點。","D. 環狀鏈結串列的節點不儲存資料。","B","根據 2-3-2，環狀鏈結串列的獨特之處在於「尾節點的引用會指向頭節點」，形成首尾相接的環形結構。"
"2","easy","根據 2-5-2，為什麼鏈結串列被認為是「快取不友好（Cache Unfriendly）」的？","A. 因為它佔用太多記憶體。","B. 因為它不支援隨機存取。","C. 因為節點分散儲存，不保證記憶體連續性，降低 Cache 命中率。","D. 因為它只能單向遍歷。","C","根據 2-5-2，由於節點在記憶體中是「分散儲存的，不保證記憶體連續性」，這會降低 CPU 快取命中率。"
"2","medium","根據 2-2-2 的程式碼邏輯，若要在節點 `prev_node` 之後插入新節點 `new_node`，下列哪一個操作順序是正確的（避免斷鏈）？","A. 先執行 `prev_node.next = new_node`，再執行 `new_node.next = prev_node.next`。","B. 先執行 `new_node.next = prev_node.next`，再執行 `prev_node.next = new_node`。","C. 同時執行兩個賦值操作，順序不影響。","D. 只需執行 `prev_node.next = new_node`，系統會自動處理後續連結。","B","根據 2-2-2 程式碼範例，必須先將 `new_node.next` 指向 `prev_node` 原本的下一個節點，然後再將 `prev_node.next` 更新為 `new_node`。若先執行 A 的操作，`prev_node` 原本的後續節點位址會遺失。"
"2","medium","依據 2-2-3，關於刪除節點的操作，下列敘述何者正確描述了被刪除節點的狀態？","A. 被刪除的節點記憶體會立即被作業系統回收。","B. 雖然被刪除節點可能仍指向下一個節點，但從鏈結串列頭部已無法訪問到它。","C. 被刪除節點的 `data` 值會自動歸零。","D. 必須將被刪除節點的 `next` 指標設為 `Null` 才能完成刪除。","B","根據 2-2-3，「儘管在刪除操作完成後，被刪除的節點 P 可能仍然指向 n1，但透過走訪鏈結串列已無法再訪問到 P」，意味著它不再屬於該串列。"
"2","medium","根據 2-6-2，為什麼「雙向鏈結串列」特別適合用於實作 LRU（Least Recently Used）演算法？","A. 因為 LRU 需要大量的記憶體空間，雙向鏈結串列剛好符合。","B. 因為 LRU 需要頻繁地在已知位置進行刪除與新增節點操作，雙向鏈結串列對此非常高效。","C. 因為 LRU 演算法只需要單向遍歷資料。","D. 因為雙向鏈結串列可以形成環狀結構，配合時間片輪轉。","B","根據 2-6-2，LRU 需要「快速找到最近最少使用的資料，並支援快速地新增和刪除節點」。雙向鏈結串列因其高效的插入和刪除特性（特別是在知道節點位置的情況下）非常適合。"
"2","medium","參考 2-4-2 的記憶體效率比較，雖然鏈結串列每個節點有額外的指標開銷，但在什麼情況下它可能比陣列更節省「整體」記憶體？","A. 當資料量非常小的時候。","B. 當陣列為了容納未來資料而預先分配了過大的空間（導致浪費）時。","C. 當資料需要頻繁讀取時。","D. 當鏈結串列使用雙向指標時。","B","根據 2-4-2，陣列「若預先分配過大的空間，可能導致記憶體浪費」，而鏈結串列「動態調整大小的特性有助於避免不必要的記憶體浪費」。"
"2","medium","根據 2-3-3 雙向鏈結串列的特性，若 `ptr` 是一個指向某節點的指標，下列哪個等式恆成立（假設節點前後皆存在）？","A. `ptr == ptr.next.next`","B. `ptr == ptr.prev.prev`","C. `ptr == ptr.next.prev`","D. `ptr == ptr.data`","C","根據 2-3-3，`ptr` 應該等於「ptr 的右鏈結再取左鏈結」，即 `ptr.next.prev` (或是 `ptr.rlink.llink`)。這反映了雙向連結的對稱性。"
"2","medium","依據 2-6-1，當使用單向鏈結串列實作「佇列（Queue）」時，為了滿足 FIFO（先進先出）特性，通常會如何操作？","A. 在同一端進行插入與刪除。","B. 在一端進行插入，在另一端進行刪除。","C. 隨機位置插入，固定位置刪除。","D. 只能在尾端進行插入與刪除。","B","根據 2-6-1，佇列表現出 FIFO 特性，「當插入操作在鏈結串列的一端進行，而刪除操作在鏈結串列的另一端進行時」可實現之。"
"2","medium","根據 2-3-2 的程式碼範例，當建立一個包含三個節點（n1, n2, n3）的環狀鏈結串列時，關鍵的連接步驟為何？","A. `n3.next = None`","B. `n3.next = n1`","C. `n1.next = n3`","D. `n2.next = n1`","B","根據 2-3-2 範例，必須將最後一個節點的 `next` 指向頭節點（`n3.next = n1`）才能形成環。"
"2","medium","根據 2-4-3 的操作效率對比表，下列哪項操作在「陣列」中的效率優於「鏈結串列」？","A. 在開頭插入元素。","B. 在開頭刪除元素。","C. 訪問元素（隨機存取）。","D. 在任意位置插入元素。","C","根據 2-4-3 表格，陣列的訪問元素為 $O(1)$，鏈結串列為 $O(n)$。而選項 A、B、D 中，鏈結串列在開頭操作是 $O(1)$ 優於陣列的 $O(n)$，任意位置插入則是陣列需搬移元素較慢。"
"2","medium","根據 2-2-5 的搜尋程式碼 `search(head, target)`，若遍歷完整個鏈結串列都未找到目標值，函式會回傳什麼？","A. `None`","B. `False`","C. `-1`","D. 拋出例外錯誤","C","根據 2-2-5 程式碼範例，若 `while curr:` 迴圈結束仍未 return，最後一行是 `return -1`。"
"2","medium","依據 2-1-3 的 Python `Node` 類別定義，初始化一個新節點 `Node(10)` 後，該節點的 `next` 屬性預設為何？","A. `10`","B. `Node(10)`","C. `None`","D. 未定義","C","根據 2-1-3 程式碼 `self.next = None`，新建立的節點預設指向 `None`。"
"2","hard","根據 2-4-3 的比較表與 2-2 章節的描述，若要在「結尾」進行插入操作，鏈結串列的時間複雜度為何，且原因為何？","A. 總是 $O(1)$，因為只需修改尾節點指標。","B. 總是 $O(n)$，因為必須從頭遍歷到尾端。","C. 若只維護頭指標（Head）則為 $O(n)$，因為需遍歷找到尾端；若有維護尾指標則可為 $O(1)$。","D. 總是 $O(1)$，因為 Python 的 list 可以在尾端快速新增。","C","根據 2-4-3 表格註記，「在結尾插入/刪除」為「$O(n)$ (若只維護頭指標)」。這是因為必須先從頭遍歷 $O(n)$ 找到最後一個節點才能操作。"
"2","hard","根據 2-6-1，在「圖（Graph）」的資料結構中，鄰接表（Adjacency List）通常如何使用鏈結串列？","A. 用一個巨大的鏈結串列儲存所有頂點與邊。","B. 每個頂點都關聯一個鏈結串列，該串列儲存與該頂點相連的其他頂點。","C. 使用雙向鏈結串列來表示圖的邊，使用陣列表示頂點。","D. 將圖的所有邊轉換為環狀鏈結串列以方便遍歷。","B","根據 2-6-1，「圖的每個頂點都與一個鏈結串列相關聯，鏈結串列中的每個元素代表與該頂點相連的其他頂點」。"
"2","hard","綜合 2-2-2 與 2-4-3，關於「在任意位置插入」的操作，雖然鏈結串列修改引用的動作是 $O(1)$，但為何整體複雜度常被標示為 $O(n)$？","A. 因為修改引用的動作實際上很慢。","B. 因為必須先花 $O(n)$ 的時間找到要插入的目標位置（前一個節點）。","C. 因為插入後需要重新整理記憶體空間。","D. 因為 Python 的物件建立需要 $O(n)$ 時間。","B","根據 2-4-3 表格註記「找到位置需 $O(n)$，實際修改引用 $O(1)$」。除非已經持有插入點的引用，否則搜尋位置的成本主導了整體複雜度。"
"2","hard","根據 2-6-2，為什麼瀏覽器的「上一頁/下一頁」功能適合用雙向鏈結串列實作，而非單向鏈結串列？","A. 因為單向鏈結串列無法儲存網址資料。","B. 因為使用者可能隨時新增新的瀏覽紀錄。","C. 因為單向鏈結串列只能往後追蹤，無法直接從當前頁面回溯到「前一個」頁面。","D. 因為雙向鏈結串列比較節省記憶體。","C","根據 2-6-2，雙向鏈結串列的特性是「可以朝兩個方向（向前和向後）走訪」，這對應了瀏覽器需要「快速知道使用者訪問過的前一個和後一個網頁」的需求。單向鏈結無法直接回頭。"
"2","hard","根據 2-3-2 與 2-3-3，當鏈結串列中「只有一個元素」時，關於環狀鏈結串列與雙向鏈結串列的指向狀態，下列敘述何者正確？","A. 環狀鏈結串列的 next 指向 Null；雙向鏈結串列的 next 與 prev 指向 Null。","B. 環狀鏈結串列的 next 指向自身；雙向鏈結串列的 next 與 prev 皆指向自身。","C. 環狀鏈結串列的 next 指向自身；雙向鏈結串列的 next 指向 Null，prev 指向 Null。","D. 兩者的所有指標都指向 Null。","B","根據 2-3-2，「當環狀鏈結串列中只有一個元素時...next 引用會指向自身」；根據 2-3-3，「當雙向鏈結串列只有一個元素時，該節點的 next 和 prev 引用會同時指向自身」。"
"2","hard","根據 2-6-1，在雜湊表（Hash Table）中，鏈結串列主要用於解決什麼問題？","A. 雜湊函數的計算速度問題。","B. 雜湊衝突（Hash Collision），將衝突的元素組織成一個鏈結串列。","C. 雜湊表的容量擴充問題。","D. 雜湊表的鍵值對應問題。","B","根據 2-6-1，「在解決雜湊衝突時...所有發生衝突的元素會被組織到一個鏈結串列中」。此即鏈式位址法。"
"2","hard","參考 2-5-2 與 2-1-4，儘管鏈結串列具有動態大小的優點，但其「記憶體開銷」與「快取友善度」的缺點在高效能運算中可能導致什麼後果？","A. 程式崩潰，因為記憶體碎片化。","B. 雖然總記憶體用量可能比預分配的陣列少，但因指標佔用與 Cache Miss，實際執行速度可能低於陣列。","C. 鏈結串列的存取速度會變成 $O(1)$，但寫入速度變慢。","D. 鏈結串列會自動轉轉換為陣列以提升效能。","B","綜合 2-5-2，鏈結串列有「額外的記憶體開銷（指標）」且「快取不友好（降低 Cache 命中率）」。這意味著在追求極致效能或資料連續性重要的場景下，其執行效率可能不如陣列。"
"2","hard","根據 2-2-3 刪除節點的程式碼 `if head and head.data == key: return head.next`，這行程式碼處理了哪種特殊情況？","A. 刪除的是中間節點。","B. 鏈結串列為空。","C. 欲刪除的節點剛好是「頭節點」。","D. 欲刪除的節點不存在。","C","根據 2-2-3 程式碼註解「刪除第一個節點」，若頭節點就是要刪除的目標，則直接回傳 `head.next` 作為新的頭，這是處理刪除頭節點的特殊邏輯。"
"2","hard","根據 2-4-1，關於「容量擴展」的機制，陣列與鏈結串列的根本差異為何？","A. 陣列可以原地擴充；鏈結串列需要複製整個串列。","B. 陣列擴展通常需分配新區塊並複製元素；鏈結串列只需在執行時動態分配新節點記憶體。","C. 陣列與鏈結串列都需要重新分配記憶體來擴充。","D. 陣列長度可變，鏈結串列長度固定。","B","根據 2-4-1，陣列擴展「通常需要分配一個更大的新記憶體區塊，然後將所有現有元素複製到新區塊中」；鏈結串列則「可以根據需求在執行時彈性地分配...靈活擴展」。"
"2","hard","根據 2-6-3，在音訊或影片播放器的「資料緩衝區」應用中，使用環狀鏈結串列的主要效益為何？","A. 可以快速倒帶。","B. 可以無限儲存資料。","C. 實現無縫播放，確保資料的循環利用（緩衝塊重複使用）和連續性。","D. 可以將音訊轉換為影片格式。","C","根據 2-6-3，資料流被放入環狀鏈結串列，「這有助於實現無縫播放，確保資料的循環利用和連續性」。"