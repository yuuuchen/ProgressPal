chapter,difficulty,question,option_A,option_B,option_C,option_D,answer,explanation
3,easy,根據教材定義，堆疊（Stack）是一種遵循什麼原則的線性資料結構？,A. 先進先出（FIFO）,B. 後進先出（LIFO）,C. 隨機存取（Random Access）,D. 優先順序（Priority）,B,"""堆疊的核心運作原則就是「後進先出」（LIFO），這意味著最後被放進去的資料，會是第一個被拿出來的。"""
3,easy,教材中使用什麼生活範例來比喻堆疊的操作特性？,A. 一排排隊的人,B. 一疊煎餅,C. 一個環形跑道,D. 一個樹狀結構,B,"""堆疊的操作特性就像一疊煎餅，你只能將煎餅疊在最上面，也只能從最上面拿取，這生動地展示了後進先出的概念。"""
3,easy,在堆疊的基本操作中，「Push」代表什麼意思？,A. 移除並回傳堆疊頂端元素,B. 檢查堆疊是否為空,C. 將新元素加入堆疊頂端,D. 回傳堆疊頂端元素但不移除它,C,"""在堆疊的術語中，「Push」專指將一個新的元素「推入」或加入到堆疊的最頂端位置。"""
3,easy,若要「回傳堆疊頂端元素但不移除它」，應該使用哪一個操作？,A. Pop,B. Push,C. Size,D. Peek,D,"""「Peek」操作的作用就是讓我們偷看（Peek）一下堆疊頂端是什麼，但不會把它拿走（移除），這與會移除元素的 Pop 不同。"""
3,easy,關於「Pop」操作的描述，下列何者正確？,A. 僅回傳元素，不移除,B. 僅移除元素，不回傳,C. 移除並回傳堆疊頂端元素,D. 檢查堆疊大小,C,"""「Pop」操作是用來取資料的，它會將堆疊最頂端的元素拿出來（移除），同時將該元素的值回傳給呼叫者。"""
3,easy,使用 Python 列表（List）實作堆疊的主要優點是什麼？,A. 推入操作永遠是 O(1),B. 簡單易於理解與使用，不需額外模組,C. 需要額外空間存儲指標,D. 適合處理超大規模資料集,B,"""使用 Python 內建的列表來當作堆疊，最大的好處就是語法簡單、直覺，而且不需要另外匯入（import）任何模組就能直接使用。"""
3,easy,使用鏈結串列（Linked List）實作堆疊的主要優點之一是什麼？,A. 程式碼最簡單,B. 不需要額外記憶體空間,C. 堆疊大小可動態變化，不受限陣列大小,D. 支援隨機存取,C,"""鏈結串列是由節點一個接一個串起來的，記憶體配置是動態的，因此堆疊大小可以隨時變化，不會像傳統陣列那樣有固定容量的限制。"""
3,easy,下列哪項功能通常使用兩個堆疊來實作？,A. 瀏覽器歷史紀錄,B. Undo/Redo（撤銷/重做）功能,C. 函式呼叫堆疊,D. 表達式計算,B,"""Undo（撤銷）與 Redo（重做）通常需要兩個堆疊配合：一個存當下的操作紀錄，當使用者撤銷時，就將該紀錄移到另一個堆疊，以便之後可以隨時「重做」回來。"""
3,easy,在程式執行過程中，堆疊用於保存什麼狀態以確保函式正確返回？,A. 使用者輸入狀態,B. 網路連線狀態,C. 函式呼叫狀態,D. 檔案讀寫狀態,C,"""當程式執行函式呼叫時，電腦必須記住是從哪裡呼叫的，以便執行完後能跳回原處，這種用於暫存執行位置的結構就是「函式呼叫堆疊」。"""
3,easy,在教材的 Python 類別實作範例中，`isEmpty` 方法的主要用途是什麼？,A. 清空堆疊中的所有元素,B. 檢查堆疊是否已滿,C. 檢查堆疊是否為空,D. 增加堆疊的容量,C,"""`isEmpty` 的功能非常直觀，就是用來判斷堆疊裡面是不是沒有任何元素（空的），這通常在執行 Pop 前用來避免錯誤。"""
3,medium,在使用 Python 列表（List）實作堆疊時，下列哪個 Python 方法對應到堆疊的 `Push` 操作？,A. insert(),B. push(),C. add(),D. append(),D,"""Python 列表中的 `append()` 方法會將元素加到列表的尾端，若將列表尾端視為堆疊頂端，這正是 Push 的操作。"""
3,medium,根據教材，使用 Python 列表（List）實作堆疊的缺點是什麼？,A. 程式碼過於複雜,B. 當列表擴充時，push 操作效能可能較差,C. 無法儲存字串型態的資料,D. 需要導入外部模組才能使用,B,"""雖然 Python 列表好用，但它是動態陣列，當預設空間滿了需要自動擴充時，會涉及記憶體重新分配與複製，導致該次 Push 操作變慢。"""
3,medium,在 Python 列表實作範例中，`stack[-1]` 對應到堆疊的哪一個基本操作？,A. Pop,B. Peek,C. Push,D. Size,B,"""在 Python 中，索引 `[-1]` 代表選取列表的最後一個元素（即堆疊頂端），讀取它但不刪除它，完全符合 `Peek` 的定義。"""
3,medium,關於使用鏈結串列實作堆疊的效率，下列敘述何者正確？,A. 插入效率為 O(n)，刪除效率為 O(1),B. 插入與刪除操作效率皆穩定為 O(1),C. 插入與刪除操作效率皆為 O(n),D. 只有在堆疊為空時效率才高,B,"""鏈結串列在進行 Push 或 Pop 時，只需要改變頭部節點的指標指向即可，不需要搬移其餘資料，因此無論資料量多大，效率都穩定維持在 O(1)。"""
3,medium,鏈結串列實作堆疊時，每一個節點（Node）除了包含資料（value）外，還包含什麼？,A. 指向前一節點的指標,B. 指向下一節點的指標（next）,C. 堆疊目前的總大小,D. 堆疊的最大容量,B,"""鏈結串列的特性就是靠「指標」來串接資料，因此每個節點除了存資料本身，一定要有一個指標（next）用來告訴電腦下一個節點在哪裡。"""
3,medium,根據教材總結表，若要處理「大資料集」且要求「推入和彈出效率穩定」，最適合使用哪種實作？,A. Python 列表（List）,B. 鏈結串列（Linked List）,C. collections.deque,D. 遞迴函式,C,"""`collections.deque` 是雙向佇列，它的底層設計專門優化了兩端的增刪操作，因此在處理大量資料時，效能比一般列表更穩定且快速。"""
3,medium,在鏈結串列實作堆疊的缺點中，教材特別提到了哪一點？,A. 堆疊大小固定,B. 需額外空間存儲指標,C. 只能儲存整數,D. 擴充時效能極差,B,"""雖然鏈結串列很靈活，但它的代價是每個節點都需要多花一點記憶體空間來儲存「指向下一個節點的指標」，這就是額外的空間開銷。"""
3,medium,瀏覽器使用堆疊來記錄瀏覽頁面，當使用者按下「上一頁（後退）」時，是對堆疊進行了什麼操作？,A. Push（將當前頁面加入）,B. Peek（查看當前頁面）,C. Pop（移除並回到上一個頁面）,D. Clear（清空歷史紀錄）,C,"""當你按「上一頁」時，瀏覽器必須「移除」當前頁面並「退回」到前一個頁面，這種移除當前頂端狀態的行為就是 Pop。"""
3,medium,根據總結表，Python 列表實作與 `collections.deque` 的主要區別在於？,A. Python 列表需要額外模組，deque 不需要,B. Python 列表適合大資料集，deque 不適合,C. Python 列表無需額外模組，但重度擴充時較慢；deque 需導入模組但效率穩定,D. 兩者在效率上完全沒有差別,C,"""兩者的取捨在於：Python 列表勝在方便（不用 import），但大量擴充時效能較差；`deque` 勝在效能穩定，但需要額外載入模組。"""
3,medium,在教材的 `Stack` 類別封裝範例中，執行 `pop` 或 `peek` 前會先進行什麼檢查？,A. 檢查 `self.size` 是否超過上限,B. 檢查 `self.stack` 是否為空（isEmpty）,C. 檢查傳入的參數是否正確,D. 不做任何檢查,B,"""為了讓程式更健壯，標準的實作在嘗試取出或查看元素前，一定會先呼叫 `isEmpty()` 確認堆疊裡有東西，以免發生錯誤。"""
3,hard,在教材提供的鏈結串列實作中，當執行 `push(value)` 時，新節點 `new_node` 與原 `head` 的關係是如何建立的？,A. `new_node.next` 指向 `None`，`head` 指向 `new_node`,B. `head.next` 指向 `new_node`，然後更新 `head`,C. `new_node.next` 指向目前的 `head`，然後將 `head` 更新為 `new_node`,D. `new_node` 替換掉 `head`，原本的 `head` 被丟棄,C,"""為了把新節點放在最上面，我們必須先讓新節點的 `next` 抓住舊的 `head`（建立連結），然後再把 `head` 標籤貼到新節點上（更新頂端）。"""
3,hard,比較 Python 列表與鏈結串列實作堆疊，下列關於「記憶體與空間」的比較何者最符合教材敘述？,A. 列表因為需要儲存指標，所以比鏈結串列浪費空間,B. 鏈結串列雖然大小動態，但需額外空間存儲指標，是其缺點,C. 列表在擴充時不需要額外記憶體分配,D. 鏈結串列的節點不需要儲存資料，只儲存指標,B,"""這裡考的是空間成本的概念。鏈結串列雖然靈活，但每個節點都要多存一個指標（Reference），若資料量大且單個資料很小，指標佔用的額外空間比例就會很可觀。"""
3,hard,關於「Undo/Redo」功能的實作細節，若僅使用一個堆疊，會遇到什麼問題而無法完全滿足教材描述的功能？,A. 無法記錄最新的操作,B. 只能做撤銷（Undo），無法在撤銷後進行重做（Redo）,C. 堆疊會因為操作過多而溢位,D. 資料結構會變成佇列（Queue）,B,"""如果只有一個堆疊，當你執行「撤銷」把動作 Pop 出來後，該動作就消失了。為了能「重做」（Redo），必須把 Pop 出來的動作存到第二個堆疊暫存起來才行。"""
3,hard,在鏈結串列實作的 `pop()` 方法中，若堆疊非空，執行 `self.head = self.head.next` 這行程式碼的意義是什麼？,A. 刪除整個鏈結串列,B. 將堆疊頂端指標移動到下一個節點，邏輯上移除了原本的頂端節點,C. 將下一個節點的值複製到目前節點,D. 檢查堆疊是否為空,B,"""這行程式碼是移除節點的關鍵。它將頭部指標直接跳過第一個節點，指向第二個節點，這樣原本的第一個節點就脫離了鏈結，達到了刪除的效果。"""
3,hard,某工程師需要開發一個模組，不能依賴標準庫以外的任何 `import`，且該模組的堆疊操作次數極為頻繁但資料量不大。根據教材總結表，他應選擇哪種實作？,A. Python 列表（List）,B. collections.deque,C. 鏈結串列（Linked List）,D. Numpy Array,A,"""關鍵在於「不能依賴 import」且「資料量不大」。雖然列表擴充慢，但在資料量小時影響甚微，加上它不需要 import，是符合該特定限制的最佳選擇。"""
3,hard,"在教材的鏈結串列實作中，若連續執行 `push(10)`, `push(20)`, `pop()`, `push(30)`，最後 `peek()` 的結果為何？",A. 10,B. 20,C. 30,D. Stack is empty,C,"""請跟著操作走：先放入 10，再放入 20（頂端是 20），接著 Pop 把 20 拿掉（頂端變回 10），最後再放入 30。所以現在頂端自然是 30。"""
3,hard,教材提到 Python 列表的 `pop()` 方法與鏈結串列的 `pop()` 方法在「底層運作」上的主要差異推論？,A. 列表的 pop 涉及陣列索引操作；鏈結串列的 pop 涉及指標更新,B. 列表的 pop 不需要回傳值；鏈結串列需要,C. 列表的 pop 是先進先出；鏈結串列是後進先出,D. 兩者底層運作完全相同,A,"""這題考的是對資料結構底層的理解。列表底層是陣列，操作涉及索引計算；而鏈結串列底層是節點，操作涉及更改指標（Next）的指向。"""
3,hard,在編譯器與計算器中，堆疊被用來處理「表達式計算與語法分析」。下列哪種具體操作符合教材描述？,A. 將程式碼轉換為二進位檔,B. 處理中序、後序表達式轉換與運算,C. 最佳化記憶體配置,D. 進行網路封包的排序,B,"""在電腦科學中，為了方便計算數學式，常利用堆疊將人類習慣的中序表達式（如 1+2）轉換成電腦好算的後序表達式，這是堆疊的經典應用。"""
3,hard,在類別封裝堆疊範例中，若未檢查 `isEmpty()` 直接對空堆疊執行 Python 原生 `pop()`，會發生什麼事（基於 Python 列表特性推論）？,A. 回傳 None,B. 程式會拋出錯誤（IndexError）,"C. 自動回傳字串 ""Stack is empty""",D. 堆疊大小變為 -1,B,"""這題考驗對 Python 語言特性的熟悉度。如果不自己寫 `if` 判斷來擋，直接對空的 Python list 執行 `pop()`，程式會崩潰並拋出 `IndexError`。"""
3,hard,為什麼教材中提到鏈結串列實作的優點是「堆疊大小可動態變化，不受限陣列大小」？這是在對比哪種潛在限制？,A. 鏈結串列永遠比陣列快,B. 固定大小的陣列在滿了之後無法再加入元素或需高成本複製,C. Python 的列表無法動態調整大小,D. 鏈結串列不需要記憶體,B,"""這是在與傳統的「固定大小陣列」做對比。傳統陣列一開始宣告多少就是多少，滿了就很麻煩；而鏈結串列像鍊子一樣，可以隨時加長，不受初始容量限制。"""
4,easy,根據教材，佇列（Queue）遵循什麼樣的原則？,先進後出（FILO）,先進先出（FIFO）,隨機存取（Random Access）,後進先出（LIFO）,B,佇列是一種線性資料結構，其核心運作原則是先進先出（FIFO），意即最先排隊加入的元素會最先被移除，就像超市結帳排隊一樣。
4,easy,在佇列的基本操作中，哪一個動作負責「將元素加入佇列尾端」？,Dequeue,Peek,Enqueue,isEmpty,C,Enqueue 代表入隊操作，負責將新元素加入到佇列的尾端；而 Dequeue 才是將元素從頭端移除。
4,easy,若要取得佇列頭端元素但不移除它，應使用哪個操作？,Enqueue,Dequeue,Size,Peek,D,Peek 操作專門用於查看佇列最前端的資料，但不會執行移除動作，讓使用者能檢視下一個要被處理的元素。
4,easy,使用 Python 列表（list）實作佇列時，教材建議使用哪個方法來進行 Dequeue？,remove(),pop(),pop(0),delete(),C,為了模擬佇列移除頭端元素的行為，Python 列表需使用 pop(0) 來取出索引值為 0 的第一個元素。
4,easy,下列哪一個**不是**教材中提到的佇列應用場景？,超市收銀台排隊,堆疊盤子,作業系統排程,印表機工作管理,B,堆疊盤子通常是後進先出（LIFO）的堆疊（Stack）概念；而超市排隊、作業系統排程與印表機管理皆是典型的先進先出（FIFO）佇列應用。
4,easy,在鏈結串列（Linked List）實作的佇列中，Dequeue 操作會移除哪個位置的節點？,尾節點（rear）,頭節點（front）,中間節點,隨機節點,B,由於佇列是先進先出，Dequeue 必須移除最早進入的資料，在鏈結串列結構中，這對應到 front 指標所指向的頭節點。
4,easy,若需要一個「執行緒安全」且內建鎖機制的佇列，教材建議使用哪一個？,Python list,collections.deque,queue.Queue,Linked List,C,queue.Queue 是 Python 標準庫提供的類別，設計上內建了鎖機制，專門用於多執行緒環境下安全地存取資料。
4,easy,優先佇列（Priority Queue）與一般佇列的主要差別為何？,優先佇列遵循 FIFO,優先佇列依優先順序排序而非 FIFO,優先佇列只能存整數,優先佇列沒有 Enqueue 操作,B,一般佇列嚴格遵守先來後到（FIFO），而優先佇列則是根據元素的「優先權」高低來決定誰先被處理，不一定是最先到達的。
4,easy,使用 Python 列表（list）實作佇列時，使用哪個方法進行 Enqueue？,push(),insert(),add(),append(),D,Python 列表的 append() 方法會將元素加到列表的最後面，符合佇列 Enqueue 加入尾端的定義。
4,easy,根據教材，作業系統排程常使用佇列來管理程序，例如哪種方式？,後進先出（LIFO）,最短作業優先,先來先服務（FCFS）,隨機服務,C,作業系統中的先來先服務（FCFS）排程策略，正是利用佇列先進先出的特性，確保先到達的程序先獲得 CPU 資源。
4,medium,使用 Python 列表（list）實作佇列時，為什麼 `pop(0)` 被認為有缺點？,因為它無法回傳數值,因為它會導致所有元素前移，時間複雜度為 O(n),因為它只能刪除最後一個元素,因為它需要額外的記憶體空間,B,Python 列表底層是連續記憶體，移除第一個元素後，後續所有元素都必須向前移動填補空缺，資料量大時效率較差（O(n)）。
4,medium,相較於 Python 列表，使用鏈結串列（Linked List）實作佇列的主要優點為何？,程式碼最精簡,不需要定義類別,加入或移除節點時不需資料搬移,可以直接使用 index 存取任意元素,C,鏈結串列透過指標連接節點，移除頭節點時只需更新指標指向，不需要像列表一樣搬移其餘資料，因此在刪除操作上效率較好。
4,medium,在鏈結串列實作的佇列節點（Node）類別中，除了儲存資料（data）外，還包含什麼？,指向上一節點的指標,指向下一節點的指標,佇列的長度,佇列的尾端位置,B,鏈結串列的基礎單元是節點（Node），每個節點必須包含「資料本身」以及「指向下一個節點的指標（next）」，才能串連成列。
4,medium,根據教材，`collections.deque` 的特性為何？,是單向佇列，只能從尾端操作,是雙端佇列，可雙端進行元素的新增與刪除,是執行緒安全佇列，內建鎖機制,依優先順序排序,B,collections.deque 是雙端佇列（Double-ended Queue），其設計目的是為了讓使用者能高效地在頭尾兩端同時進行插入與刪除操作。
4,medium,在廣度優先搜尋（BFS）演算法中，使用佇列的主要目的為何？,確保搜尋順序由遠至近,記錄已訪問過的節點數量,記錄待訪節點，保證搜尋順序由近至遠,節省記憶體空間,C,BFS 需要層層向外擴散搜尋，使用佇列（FIFO）可以確保先遇到的鄰居節點先被處理，從而保證搜尋順序是由起點由近至遠。
4,medium,關於網路資料封包處理，佇列扮演什麼角色？,封包到達後立即丟棄,封包會暫存在佇列中，再依序傳送,封包會被隨機重新排序,佇列用來加密封包內容,B,當封包進入路由器時，若處理速度不及流量，封包會被暫存在佇列緩衝區中，依照到達順序排隊等待傳送，避免直接遺失。
4,medium,在鏈結串列的 Enqueue 實作中，若 `self.rear` 已經存在（非 None），新節點應該接在哪裡？,`self.front` 的前面,`self.rear` 的 `next`，並更新 `self.rear`,直接取代 `self.front`,直接取代 `self.rear` 而不連接舊節點,B,當佇列非空時，新元素應接在目前尾端節點（rear）的後面（即 rear.next），接著再將 rear 指標更新指向這個新節點。
4,medium,根據教材，鏈結串列實作佇列的缺點是什麼？,無法動態增減元素,移除頭元素時需要搬移資料,每個元素需額外存儲指標，程式碼相對較複雜,只能儲存整數資料,C,雖然鏈結串列效率好，但每個節點都需要額外的記憶體來儲存 next 指標，且需要自行管理節點連接邏輯，程式碼比使用內建列表複雜。
4,medium,當使用類別封裝佇列時，`dequeue` 方法在佇列為空時會回傳什麼？,None,FALSE,"錯誤訊息字串 ""Queue is empty""",0,C,"為了避免程式崩潰或回傳錯誤數據，教材範例中設計了檢查機制：若 isEmpty 為真，則回傳特定的提示字串 ""Queue is empty""。"
4,medium,關於 `queue.Queue` 的敘述，下列何者正確？,它適合用於單執行緒的小型腳本,它不具備鎖機制,它適合多工任務排程與即時系統,它是為了雙端操作設計的,C,queue.Queue 是專為多執行緒設計的，具備鎖機制可防止資料競爭，因此非常適合用於需要並發處理的多工任務排程系統。
4,hard,在鏈結串列實作的 `dequeue` 方法中，執行 `self.front = temp.next` 之後，接下來必須檢查什麼條件以維護正確性？,檢查 `self.rear` 是否為 None,檢查 `self.front` 是否變為 None，若是則需將 `self.rear` 也設為 None,檢查 `self.length` 是否大於 10,檢查 `new_node` 是否存在,B,若 Dequeue 移除了佇列中最後一個元素，front 會變成 None。此時必須同步將 rear 也設為 None，否則 rear 會指向一個已經被移除的節點，導致狀態錯誤。
4,hard,"若執行以下 Python 列表操作：`q = []`, `q.append('X')`, `q.append('Y')`, `q.pop(0)`, `q.append('Z')`。最後佇列的內容為何？","['X', 'Y', 'Z']","['Y', 'Z']","['X', 'Z']",['Z'],B,"操作順序追蹤：1. 加入 X (['X']) -> 2. 加入 Y (['X', 'Y']) -> 3. 移除頭端 X (['Y']) -> 4. 加入 Z (['Y', 'Z'])。"
4,hard,關於各種佇列實作的比較，下列敘述何者完全符合教材內容？,Python 列表適合大規模資料，因為 append 很快,鏈結串列實作雖然效率好，但缺點是節點需連續儲存,`queue.Queue` 效率最高，因為它沒有鎖機制,鏈結串列不需要資料搬移，但每個元素需額外存儲指標,D,鏈結串列的優勢在於不需搬移資料即可插入刪除，代價是需要額外記憶體儲存指標；A 錯在列表不適合大規模 Dequeue，B 錯在鏈結串列不需連續儲存，C 錯在 queue.Queue 有鎖機制。
4,hard,在鏈結串列實作的 `enqueue` 函式中，為什麼需要 `if self.rear is None:` 的判斷？,因為佇列滿了需要擴充,因為這代表佇列目前是空的，頭尾指標都需指向新節點,因為要檢查傳入的 element 是否為 None,因為要防止記憶體溢出,B,當 rear 為 None 時，表示佇列原本是空的。此時加入的第一個節點既是頭也是尾，因此需要同時更新 front 和 rear 指向該新節點。
4,hard,教材提到佇列可用於「模擬系統（Simulation）」，其具體運作邏輯為何？,模擬隨機發生的錯誤,用於模擬顧客到達、機器運作等需要「等待排隊」的場景,模擬 CPU 的運算速度,模擬記憶體的分配過程,B,模擬系統常利用佇列來重現現實生活中「資源有限、需要排隊等待」的現象，例如銀行櫃台服務或工廠流水線的緩衝區模擬。
4,hard,若要開發一個路徑搜尋功能（如 Dijkstra 演算法），教材建議使用哪種資料結構？,標準 FIFO 佇列,雙端佇列（Deque）,優先佇列（Priority Queue）,堆疊（Stack）,C,Dijkstra 演算法需要每次都從當前路徑中挑選成本（距離）最小的節點進行延伸，這需要依照數值排序而非先進先出，因此適合使用優先佇列。
4,hard,根據教材的鏈結串列實作，`size()` 方法是如何取得佇列大小的？,每次呼叫時遍歷整個串列計算,計算 `rear` 和 `front` 記憶體位置的差值,直接回傳維護好的 `self.length` 屬性,使用 Python 內建的 `len()` 函式計算節點數,C,為了提升效率，教材中的實作在 Enqueue 和 Dequeue 時會動態增減一個 length 計數器，因此 size() 只需回傳這個屬性值，不需要重新計算。
4,hard,關於 `queue.Queue` 與 `collections.deque` 的適用情境區別，下列何者正確？,前者適合多執行緒環境，後者適合需要頻繁頭尾操作的高效情境,前者適合單執行緒，後者適合多執行緒,兩者功能完全相同，只差在命名,前者用於圖形演算法，後者用於作業系統排程,A,`queue.Queue` 著重於執行緒安全性（Thread Safety），適合併發程式；而 `collections.deque` 著重於資料結構操作的效能，適合需要快速雙端存取的演算法實作。
4,hard,在鏈結串列實作中，若 `front` 與 `rear` 指向同一個節點，這代表什麼意義？,佇列是空的,佇列已滿,佇列中只有一個元素,佇列中有兩個元素,C,當 front（頭）和 rear（尾）指向同一個物件時，表示該佇列中僅存這唯一的一個節點。
4,hard,為何訊息佇列（Message Queue）在分布式系統中可以避免資料遺失？,因為它會優先處理重要的封包,因為它可暫存資料封包或任務，緩衝處理速度的差異,因為它使用 LIFO 機制確保最新資料先到,因為它會自動複製資料到硬碟,B,訊息佇列充當緩衝區，當發送端速度快於接收端，或網路不穩定時，資料可以先暫存在佇列中等待處理，確保不會因為來不及處理而直接丟失。
