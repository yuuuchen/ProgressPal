
chapter,difficulty,question,option_A,option_B,option_C,option_D,answer,explanation
"1","easy","根據 1-1-1 陣列的定義，下列關於陣列特性的描述何者正確？","選項A: 陣列是由不同型別元素組成的非線性資料結構。","選項B: 陣列的所有元素依序存放於連續記憶體中。","選項C: 陣列的存取效率通常為 O(n)。","選項D: 陣列的索引通常從 1 開始，以方便人類閱讀。","B","""正確答案為 B。根據 1-1-1，陣列是由『相同型別』元素組成的『線性』資料結構，且『所有元素依序存放於連續記憶體中』。選項 A 錯在不同型別與非線性；選項 C 錯在存取效率應為 O(1)；選項 D 錯在索引通常從 0 開始。"""
"1","easy","依據 1-1-2，下列何者不是使用陣列的主要理由？","選項A: 能夠統一管理大量資料，提升程式可讀性。","選項B: 利用索引存取，時間複雜度達到 O(1)。","選項C: 陣列結構可以動態無限擴充，不需要考慮記憶體限制。","選項D: 計算方便，例如可用迴圈遍歷計算平均值。","C","""正確答案為 C。根據 1-1-2，使用陣列的理由包括統一管理大量資料、快速存取元素 (O(1)) 以及計算方便。選項 C 的敘述並未在 1-1-2 中被列為使用理由，且 1-8-2 提到陣列的缺點是大小固定（傳統陣列概念）。"""
"1","easy","根據 1-4-1，陣列的元素在記憶體中是如何存放的？","選項A: 隨機散落在記憶體的不同區域。","選項B: 透過鏈結串列的方式連接不連續的記憶體區塊。","選項C: 依序存放於連續的記憶體區域。","選項D: 依據雜湊函數存放在雜湊表中。","C","""正確答案為 C。根據 1-4-1，陣列元素『存放於記憶體連續區域』。這使得只需知道起始位址與元素大小即可計算位置。"""
"1","easy","依據 1-2-1 與 1-2-3，在 Python 語言中，通常使用哪種資料型態來模擬一維陣列？","選項A: Dictionary","選項B: Tuple","選項C: Set","選項D: List (串列)","D","""正確答案為 D。根據 1-2-1，『在 Python 中可用串列模擬一維陣列』；1-2-3 提到 Python 常用 list 當作動態陣列。"""
"1","easy","根據 1-7-1，陣列在「讀取元素」上的時間複雜度為何？","選項A: O(1)","選項B: O(n)","選項C: O(log n)","選項D: O(n^2)","A","""正確答案為 A。根據 1-7-1，陣列存取效率高，因為元素位址可直接計算，因此存取任意索引皆為 O(1)。"""
"1","easy","根據 1-3-4，若要使用「二分搜尋」來加快搜尋效率，陣列必須滿足什麼條件？","選項A: 陣列必須是二維的。","選項B: 陣列必須包含字串。","選項C: 陣列必須是已排序的 (Ordered/Sorted)。","選項D: 陣列必須使用 NumPy 建立。","C","""正確答案為 C。根據 1-3-4，『有序陣列可利用二分搜尋加快搜尋效率』。若未排序則需使用線性搜尋。"""
"1","easy","根據 1-1-1 的譬喻，教材將陣列想像成什麼？","選項A: 一串串在一起的珍珠項鍊。","選項B: 一排盒子，每個盒子內有資料，位置固定且編號唯一。","選項C: 一棵有很多分岔的樹。","選項D: 一個堆滿盤子的堆疊。","B","""正確答案為 B。根據 1-1-1，教材提到『可以把陣列想像成一排盒子，每個盒子內有資料，位置固定且編號唯一』。"""
"1","easy","依據 1-8-2，下列何者被列為陣列的缺點？","選項A: 結構太過複雜，難以實作。","選項B: 不支援隨機存取。","選項C: 插入和刪除效率低，需搬移大量元素。","選項D: 無法用於儲存整數資料。","C","""正確答案為 C。根據 1-8-2，陣列的缺點包括『陣列大小固定』以及『插入和刪除效率低』，因為需搬移元素。選項 A、B 都是陣列的優點（1-8-1）。"""
"1","easy","根據 1-5-2，二維陣列的結構類似於下列何者？","選項A: 線狀結構。","選項B: 表格結構，由行與列組成。","選項C: 立體結構，如 3D 影像。","選項D: 樹狀結構。","B","""正確答案為 B。根據 1-5-2，二維陣列是『類似表格結構，行與列的資料組合』。"""
"1","easy","依據 1-3-2，「遍歷」陣列的意思為何？","選項A: 只讀取陣列的第一個元素。","選項B: 隨機選取陣列中的一個元素。","選項C: 將陣列中的元素全部刪除。","選項D: 逐一處理陣列內的所有元素。","D","""正確答案為 D。根據 1-3-2，遍歷是指『逐一處理陣列內的所有元素』。"""
"1","medium","根據 1-3-3 關於陣列插入操作的描述，若在陣列的中間位置插入一個新元素，下列敘述何者正確？","選項A: 該位置原本的元素會被覆蓋，不需要移動其他元素。","選項B: 該位置原本的元素與後續所有元素都必須依序向後移動，以騰出空間。","選項C: 該位置原本的元素會自動移到陣列的最後面。","選項D: 陣列會自動建立一個新的記憶體區塊來存放新元素，不影響原陣列。","B","""正確答案為 B。根據 1-3-3，『若在中間插入，需將後續元素依序後移』。這是為了維持陣列記憶體的連續性。"""
"1","medium","依據 1-4-2 的位址計算公式 $A[i] = base\_address + size\_of\_element 	imes (i - lower\_bound)$，若忽略 lower_bound (設為0)，計算特定索引位址時主要依賴哪兩個參數？","選項A: 陣列的總長度與元素大小。","選項B: 起始位址與元素大小。","選項C: 起始位址與陣列的總容量。","選項D: 元素的值與元素大小。","B","""正確答案為 B。根據 1-4-2，公式中包含 base (起始位址) 與 size (元素大小)。陣列總長度或元素內容(值)並不直接參與個別元素的位址計算。"""
"1","medium","根據 1-6-1 的 Python 語法範例，若有一個二維陣列 `matrix = [[1, 2], [3, 4]]`，執行 `print(matrix[1][0])` 的結果為何？","選項A: 1","選項B: 2","選項C: 3","選項D: 4","C","""正確答案為 C。根據 1-6-1 範例邏輯，`matrix[1]` 取出第二個子串列 `[3, 4]`，接著 `[0]` 取出該子串列的第一個元素，即 3。"""
"1","medium","根據 1-3-1 的 Python 範例，使用負索引 `arr[-1]` 代表什麼意義？","選項A: 存取陣列的第一個元素。","選項B: 存取陣列中數值為 -1 的元素。","選項C: 導致程式錯誤，因為索引不能為負。","選項D: 存取陣列的最後一個元素。","D","""正確答案為 D。根據 1-3-1 範例註解，`arr[-1]` 代表從尾端開始，即『最後一個元素』。"""
"1","medium","參考 1-5 的分類，若你需要處理「深度學習中的張量 (Tensor)」或科學模擬數據，最適合使用哪種陣列類型？","選項A: 一維陣列","選項B: 二維陣列","選項C: 三維陣列","選項D: n 維陣列","D","""正確答案為 D。根據 1-5-4，『當資料維度更高時，可使用 n 維陣列，例如科學模擬、深度學習中的張量』。"""
"1","medium","根據 1-3-4，關於線性搜尋與二分搜尋的比較，下列何者正確？","選項A: 線性搜尋不需要陣列排序，時間複雜度為 O(n)。","選項B: 二分搜尋不需要陣列排序，時間複雜度為 O(log n)。","選項C: 線性搜尋效率總是比二分搜尋好，因為它檢查每個元素。","選項D: 二分搜尋可以用於任何類型的陣列，無論是否排序。","A","""正確答案為 A。根據 1-3-4 與 1-7-3，線性搜尋遍歷整個陣列 (O(n)) 且不需要排序；二分搜尋效率較高 (O(log n)) 但『限定於排序陣列』。"""
"1","medium","根據 1-2-3 與 1-6-2，為什麼在高效能處理大量數據時，會推薦使用 NumPy 的 ndarray 而非 Python 原生的 list？","選項A: 因為 Python list 無法儲存整數以外的資料。","選項B: 因為 NumPy 支援多維矩陣運算與向量化處理，且記憶體配置更適合科學計算。","選項C: 因為 Python list 的索引必須從 1 開始，不符合科學計算習慣。","選項D: 因為 NumPy 不需要安裝即可直接在 Python 中使用。","B","""正確答案為 B。根據 1-2-3，list 具彈性但若需高效能會用 NumPy；1-6-2 提到 NumPy 支援多維陣列高效計算。選項 A 錯誤，list 可存任意型別；選項 C 錯誤，list 索引從 0 開始。"""
"1","medium","根據 1-3-3，當執行陣列刪除操作 (remove) 時，為了維持結構的連續性，需要進行什麼動作？","選項A: 將被刪除位置設為 0，不移動其他元素。","選項B: 將被刪除位置標記為空，不移動其他元素。","選項C: 將被刪除位置後續的所有元素依序前移以補位。","選項D: 將陣列最後一個元素直接移到被刪除的位置。","C","""正確答案為 C。根據 1-3-3，『刪除元素後，須將後續元素依序前移以補位』。"""
"1","medium","依據 1-2-2，在 Python 中如何模擬「三維陣列」？","選項A: 使用三個獨立的變數名稱。","選項B: 使用 `matrix[x, y, z]` 的特殊語法直接宣告。","選項C: 使用「串列嵌套串列」的方式，例如 `[[[...]]]`。","選項D: Python 無法模擬三維陣列，必須強制使用 C++。","C","""正確答案為 C。根據 1-2-2，Python 中可以用『串列嵌套串列』的方式模擬多維陣列，範例中展示了 `cube = [[[...], [...]], ...]` 的結構。"""
"1","medium","根據 1-3-2，Python 提供了哪一個功能可同時取得「索引」與「元素」，提升程式可讀性？","選項A: `range()`","選項B: `enumerate`","選項C: `bisect`","選項D: `append`","B","""正確答案為 B。根據 1-3-2，『Python 也支援 enumerate，可同時取得索引與元素，提升程式可讀性』。"""
"1","hard","根據 1-4-1 與 1-7 的描述，關於 Python list 與傳統陣列（如 C/C++）在記憶體結構與存取效能上的比較，下列敘述何者正確？","選項A: 傳統陣列與 Python list 皆保證元素在實體記憶體中完全連續存放，因此存取皆為 O(1)。","選項B: Python list 屬於「動態陣列」，內部可能包含指標，但透過索引存取元素的時間複雜度仍維持 O(1)。","選項C: 由於 Python list 是動態的，其讀取元素的效率會退化成 O(n)，不如傳統陣列的 O(1)。","選項D: 傳統陣列存取元素需要遍歷記憶體，故時間複雜度為 O(n)，Python list 則為 O(1)。","B","""正確答案為 B。根據 1-4-1，Python list 是「動態陣列」，內部可能包含指標，但存取仍是 O(1)。選項 A 錯誤，因為 Python list 內部結構與傳統連續記憶體陣列不同；選項 C 錯誤，讀取仍是 O(1)；選項 D 錯誤，傳統陣列存取也是 O(1)。"""
"1","hard","依據 1-4-2 提供的位址計算公式 $A[i] = base\_address + size\_of\_element 	imes (i - lower\_bound)$，下列哪一個因素的改變**不會**影響特定索引 $i$ 的記憶體位址計算結果？","選項A: 起始位址 (base_address)","選項B: 陣列中儲存的元素值 (value of element)","選項C: 每個元素的大小 (size_of_element)","選項D: 索引的起始值 (lower_bound)","B","""正確答案為 B。根據公式，計算位址僅依賴起始位址、元素大小、索引值 $i$ 與下界 $lower\_bound$。陣列中實際儲存的「資料內容（元素值）」並不參與位址計算。其他選項 A、C、D 皆為公式中的變數，會影響計算結果。"""
"1","hard","參考 1-3-3 與 1-7-2，若在一個長度為 $n$ 的陣列之索引 0 (開頭) 進行插入操作，與在索引 $n$ (尾端，假設空間足夠) 進行插入操作，兩者在「元素搬移」上的主要差異為何？","選項A: 在開頭插入不需要搬移元素，在尾端插入需要搬移 $n$ 個元素。","選項B: 在開頭插入需要將原陣列所有 $n$ 個元素後移，時間代價最高；在尾端插入則無需搬移後續元素。","選項C: 無論在何處插入，根據 1-7-2，時間複雜度皆固定為 O(1)，無須搬移元素。","選項D: 在開頭插入僅需搬移 1 個元素，在尾端插入需搬移 $n$ 個元素。","B","""正確答案為 B。根據 1-3-3，「若在中間插入，需將後續元素依序後移」。若在索引 0 插入，後續所有元素皆須後移，成本最高。若在尾端插入且空間足夠，無後續元素需移動。選項 C 錯誤，插入包含搬移成本，複雜度為 O(n)。"""
"1","hard","根據 1-5「陣列類型介紹」的分類邏輯，下列哪一種應用場景與其對應的陣列維度描述**不符合**教材內容？","選項A: 使用「一維陣列」來處理向量或簡單資料收集。","選項B: 使用「二維陣列」來進行矩陣運算或模擬棋盤遊戲。","選項C: 使用「三維陣列」來處理深度學習中的複雜模型運算。","選項D: 使用「三維陣列」來模擬影像資料或空間資料。","C","""正確答案為 C。根據 1-5-3，三維陣列用於「模擬 3D 資料，如影像資料或空間資料」。根據 1-5-4，深度學習屬於「n 維陣列」的進階用途。故 C 選項將深度學習歸類於三維陣列是不精確的（教材將其歸類於 n 維）。"""
"1","hard","根據 1-3-4 關於搜尋的描述，若欲將搜尋的時間複雜度從線性搜尋的 O(n) 優化至二分搜尋的 O(log n)，陣列必須滿足下列哪項「必要前置條件」？","選項A: 陣列必須宣告為 NumPy 的 ndarray。","選項B: 陣列的索引必須從 1 開始 (1-based indexing)。","選項C: 陣列中的元素必須已經完成排序 (Sorted)。","選項D: 陣列的大小必須固定，不可動態擴充。","C","""正確答案為 C。根據 1-3-4，「有序陣列可利用二分搜尋加快搜尋效率」以及 1-7-3 註明二分搜尋「限定於排序陣列」。選項 A、B、D 皆非二分搜尋演算法本身的必要數學條件。"""
"1","hard","綜合 1-2-2 與 1-6-1 的內容，關於 Python 語言處理「多維陣列」的實作方式，下列敘述何者最為精確？","選項A: Python 內建了名為 Array 的多維資料型態，可直接宣告矩陣。","選項B: Python 本身沒有原生多維陣列，是利用 List 的「嵌套（串列中包含串列）」來模擬多維陣列。","選項C: Python 的 List 只能是一維的，若要使用二維陣列必須強制安裝 NumPy 套件。","選項D: Python 使用 `matrix[][]` 的特殊語法來宣告原生的固定大小二維陣列。","B","""正確答案為 B。根據 1-2-2，「在 Python 中，可以用『串列嵌套串列』的方式模擬多維陣列」；1-6-1 範例展示 `matrix = [[1, 2], [3, 4]]`。選項 A、D 錯誤，Python 無此原生型態或語法；選項 C 錯誤，Python 可用 List 模擬，非必須使用 NumPy（雖然 NumPy 更高效）。"""
"1","hard","根據 1-1-2 提到的「使用陣列的理由」，下列哪一個情境**最無法**凸顯陣列作為「線性資料結構」且擁有「連續記憶體空間」的優勢？","選項A: 需要頻繁地計算所有學生成績的平均值 (遍歷計算)。","選項B: 需要頻繁地在資料集的任意位置插入或刪除大量數據。","選項C: 需要利用索引快速讀取特定編號的資料 (如 marks[5])。","選項D: 需要統一管理大量相同型態的變數，以提升可讀性。","B","""正確答案為 B。根據 1-8-2 缺點所述，陣列的「插入和刪除效率低」（需搬移元素）。因此，頻繁插入刪除的情境無法凸顯其優勢，反而暴露其弱點。選項 A、C、D 分別對應 1-1-2 提到的計算方便、快速存取 (O(1)) 與統一管理等優勢。"""
"1","hard","關於 1-8 提到的陣列優缺點與 1-3 的操作特性，下列哪項推論是正確的？","選項A: 因為陣列支援快速存取，所以適合用於資料量大小不斷劇烈變動且需頻繁插入的場景。","選項B: 因為陣列元素依序存放於連續記憶體，刪除中間元素後，記憶體會自動產生空洞，不會影響後續元素。","選項C: 陣列雖有 O(1) 的讀取優勢，但其「尺寸固定」與「搬移成本」限制了其在動態資料處理上的靈活性。","選項D: 陣列的線性搜尋效率高達 O(1)，因此在未排序資料中尋找特定值非常快速。","C","""正確答案為 C。此選項正確結合了 1-7-1 的讀取優勢與 1-8-2 的「尺寸固定」、「插入刪除效率低」缺點。選項 A 錯誤，陣列不適合頻繁插入；選項 B 錯誤，刪除後需「前移補位」(1-3-3)；選項 D 錯誤，線性搜尋為 O(n) (1-7-3)。"""
"1","hard","根據 1-6 的比較，當需要進行高效能的多維陣列計算（如科學運算）時，為何教材建議使用 NumPy 而非 Python 原生的 List？","選項A: 因為 NumPy 的 ndarray 支援多維陣列高效計算，且是真正針對多維結構設計的，不同於 Python List 的嵌套模擬。","選項B: 因為 Python List 無法使用索引存取多維資料，例如無法寫出 `cube[1][0][1]`。","選項C: 因為 NumPy 的記憶體結構是非連續的，比起 Python List 的連續記憶體更節省空間。","選項D: 因為 Python List 的索引只能從 1 開始，不符合科學運算的 0-based indexing 標準。","A","""正確答案為 A。根據 1-6-2，NumPy 的 ndarray 支援多維陣列高效計算。且 1-2-3 提到若需高效能「真正多維陣列」通常用 NumPy。選項 B 錯誤，Python List 可以嵌套存取；選項 C 錯誤，NumPy 通常是連續記憶體優化；選項 D 錯誤，Python List 也是 0-based。"""
"1","hard","根據 1-3-1 與 1-6-1 的程式碼範例，下列關於 Python 陣列索引的解讀，何者是**錯誤**的推論？","選項A: `arr[-1]` 代表存取陣列中的最後一個元素，這是 Python 特有的負索引功能。","選項B: 若 `matrix` 為二維陣列，`matrix[1][0]` 代表存取第二列（Row 1）的第一個元素。","選項C: 在 Python List 中，`matrix[1]` 本身會回傳一個一維的 List（即該列的資料）。","選項D: 多維陣列的存取必須一次寫完所有維度的索引（如 `[x][y]`），無法單獨存取 `matrix[x]` 這一層。","D","""正確答案為 D。根據 1-2-2，Python 的多維陣列是「串列嵌套串列」。因此 `matrix[x]` 會回傳該索引對應的子串列（Sub-list），這是一個合法的操作，並非必須一次寫完所有維度。選項 A、B、C 皆符合教材範例描述。"""
